import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from turtlesim.msg import Pose
import math
import time
import matplotlib.pyplot as plt


def angle_normalize(a: float) -> float:
    """ê°ë„ë¥¼ -Ï€ ~ Ï€ ë²”ìœ„ë¡œ ì •ê·œí™”í•˜ëŠ” í•¨ìˆ˜
    - ì–´ë–¤ ê°ë„ aê°€ ë“¤ì–´ì™€ë„ [-pi, pi] ë²”ìœ„ë¡œ ë³€í™˜
    - íšŒì „ ì˜¤ì°¨ ê³„ì‚°í•  ë•Œ í•­ìƒ ì´ ë²”ìœ„ë¡œ ë‘ë©´ í¸í•¨ (wrap-around ë¬¸ì œ ë°©ì§€)
    """
    return math.atan2(math.sin(a), math.cos(a))


class PID:
    """ì¼ë°˜ì ì¸ PID ì»¨íŠ¸ë¡¤ëŸ¬ êµ¬í˜„ í´ë˜ìŠ¤"""

    def __init__(self, kp, ki, kd, clamp_i=1.0):
        # ë¹„ë¡€, ì ë¶„, ë¯¸ë¶„ ê³„ìˆ˜
        self.kp = kp
        self.ki = ki
        self.kd = kd

        # ì ë¶„í•­ ê°’
        self.integral = 0.0
        # ì´ì „ ì˜¤ì°¨ (ë¯¸ë¶„í•­ ê³„ì‚°ìš©)
        self.prev_err = 0.0

        # ì ë¶„í•­ì´ ë„ˆë¬´ ì»¤ì§€ëŠ” ê²ƒ ë°©ì§€ìš© í´ë¨í”„(anti-windup)
        self.clamp_i = clamp_i

    def reset(self):
        """ì»¨íŠ¸ë¡¤ëŸ¬ ìƒíƒœ ì´ˆê¸°í™” (ìƒˆ êµ¬ê°„ ë“¤ì–´ê°ˆ ë•Œ í˜¸ì¶œ)"""
        self.integral = 0.0
        self.prev_err = 0.0

    def update(self, err, dt):
        """í˜„ì¬ ì˜¤ì°¨ errì™€ ì‹œê°„ ê°„ê²© dtë¥¼ ë°›ì•„ PID ì¶œë ¥ ê³„ì‚°"""

        # --- ì ë¶„í•­ ì—…ë°ì´íŠ¸ ---
        self.integral += err * dt
        # ì ë¶„í•­ ì œí•œ (windup ë°©ì§€)
        self.integral = max(min(self.integral, self.clamp_i), -self.clamp_i)

        # --- ë¯¸ë¶„í•­ ê³„ì‚° ---
        derivative = (err - self.prev_err) / dt if dt > 0 else 0.0
        self.prev_err = err

        # PID ì¶œë ¥ = Kp*e + Ki*âˆ«e dt + Kd*de/dt
        return self.kp * err + self.ki * self.integral + self.kd * derivative


class TurtleSquareUltra(Node):
    """turtlesimì—ì„œ ì •ì‚¬ê°í˜•ì„ ì•„ì£¼ ì •ë°€í•˜ê²Œ ê·¸ë¦¬ê³ 
    ê·¸ ê³¼ì •ì—ì„œ ê°ì¢… ì˜¤ì°¨/ì œì–´ì…ë ¥ ë¡œê·¸ë¥¼ ìˆ˜ì§‘í•´ì„œ ê·¸ë˜í”„ê¹Œì§€ ê·¸ë ¤ì£¼ëŠ” ë…¸ë“œ
    """

    def __init__(self):
        super().__init__("turtle_square_ultra")

        # ============ ROS pub / sub ============
        # ì†ë„ ëª…ë ¹ publish
        self.pub = self.create_publisher(Twist, "turtle1/cmd_vel", 10)
        # í˜„ì¬ pose subscribe
        self.sub = self.create_subscription(
            Pose, "/turtle1/pose", self.pose_cb, 10
        )

        # pose ë°ì´í„° ì €ì¥ìš©
        self.pose = Pose()
        self.pose_ready = False  # poseë¥¼ ì•„ì§ í•œ ë²ˆë„ ëª» ë°›ì•˜ëŠ”ì§€ ì—¬ë¶€

        # ============ PID ì»¨íŠ¸ë¡¤ëŸ¬ ============
        # ì§ì§„í•  ë•Œ heading ìœ ì§€ìš© PID (angular.z ì œì–´)
        self.straight_pid = PID(kp=4.0, ki=0.01, kd=0.2, clamp_i=0.5)
        # ì œìë¦¬ íšŒì „í•  ë•Œ ëª©í‘œ ê°ë„ ë§ì¶”ëŠ” PID
        self.turn_pid = PID(kp=5.0, ki=0.02, kd=0.3, clamp_i=0.5)

        # ê¸°ì¤€ heading (0, 90, 180, 270 ì¤‘ í•˜ë‚˜ë¡œ ìŠ¤ëƒ…í•œ ê°’)
        # ì „ì²´ ì‚¬ê°í˜•ì„ ì´ ê¸°ì¤€ì¶•ì— ë§ì¶° ê·¸ë¦¼
        self.base_heading = None

        # ë¡œê·¸ìš© ê¸°ì¤€ ì‹œê°„ (t=0 ê¸°ì¤€)
        self.t0 = time.time()

        # ====== ğŸ“Š ë¡œê·¸ ë°ì´í„° ======

        # 1) ì „ì²´ ê¶¤ì  / heading (ì‹œê°„ ê¸°ì¤€)
        self.path_t = []          # ì‹œê°„
        self.path_x = []          # ìœ„ì¹˜ x
        self.path_y = []          # ìœ„ì¹˜ y
        self.path_heading = []    # heading(ê°ë„)

        # 2) ì§ì§„ êµ¬ê°„ ë¡œê·¸ (ê±°ë¦¬ ê¸°ì¤€)
        self.segment_count = 0          # ëª‡ ë²ˆì§¸ ì§ì„  ë³€ì¸ì§€ (1,2,3,...)
        self.straight_seg_idx = []      # ê° ìƒ˜í”Œì´ ì–´ëŠ ë³€ì— ì†í•˜ëŠ”ì§€
        self.lat_err_s = []             # ê·¸ ë³€ì—ì„œ ì „ì§„í•œ ê±°ë¦¬ s [m]
        self.lat_err = []               # íš¡ë°©í–¥ ì˜¤ì°¨ [m] (ì´ìƒ ì§ì„ ì—ì„œ ì˜†ìœ¼ë¡œ ì–¼ë§ˆë‚˜ ë²—ì–´ë‚¬ëŠ”ì§€)
        self.lat_head_err = []          # ì§ì§„ ì¤‘ heading ì˜¤ì°¨ [rad]
        self.straight_w = []            # ì§ì§„ ì¤‘ angular.z ì œì–´ì…ë ¥

        # 3) íšŒì „ êµ¬ê°„ ë¡œê·¸
        self.turn_err = []              # íšŒì „ ì¤‘ ìˆœê°„ìˆœê°„ì˜ ê°ë„ ì˜¤ì°¨ [rad]
        self.turn_w = []                # íšŒì „ ì¤‘ angular.z ì œì–´ì…ë ¥
        self.turn_final_err = []        # ê° í„´ì´ ëë‚¬ì„ ë•Œì˜ ìµœì¢… heading ì˜¤ì°¨ [rad]

        # 4) ê° ì½”ë„ˆì—ì„œì˜ x, y, heading ì˜¤ì°¨
        self.corner_ref = []           # ì´ìƒì ì¸ 4ê°œ ì½”ë„ˆ ì¢Œí‘œ ([(x0,y0), (x1,y1), ...])
        self.corner_err_x = []         # ì‹¤ì œ - ì´ìƒ x ì˜¤ì°¨
        self.corner_err_y = []         # ì‹¤ì œ - ì´ìƒ y ì˜¤ì°¨
        self.corner_err_heading = []   # ì½”ë„ˆë³„ heading ì˜¤ì°¨ (rad)

        self.get_logger().info("ğŸš€ TurtleSquareUltra initialized")

    # -------------------------------------------------
    # Pose ì½œë°± + ê¶¤ì /heading ì‹œê°„ ë¡œê·¸
    # -------------------------------------------------
    def pose_cb(self, msg: Pose):
        """turtlesimì´ poseë¥¼ publish í•  ë•Œë§ˆë‹¤ í˜¸ì¶œë˜ëŠ” ì½œë°±
        - í˜„ì¬ pose ì €ì¥
        - ì‹œê°„ ê¸°ì¤€ ê¶¤ì /heading ë¡œê·¸ ìŒ“ê¸°
        """
        self.pose = msg
        self.pose_ready = True

        t = time.time() - self.t0
        self.path_t.append(t)
        self.path_x.append(msg.x)
        self.path_y.append(msg.y)
        self.path_heading.append(msg.theta)

    # -------------------------------------------------
    # poseê°€ ì¤€ë¹„ë  ë•Œê¹Œì§€ spin_once
    # -------------------------------------------------
    def wait_for_pose(self):
        """ì²˜ìŒì—ëŠ” poseë¥¼ ì•„ì§ ëª» ë°›ì•˜ì„ ìˆ˜ ìˆìœ¼ë‹ˆ
        pose_readyê°€ True ë  ë•Œê¹Œì§€ spin_once ë°˜ë³µ"""
        while rclpy.ok() and not self.pose_ready:
            rclpy.spin_once(self, timeout_sec=0.05)

    # -------------------------------------------------
    # ì •ì§€ (ROS ì»¨í…ìŠ¤íŠ¸ ì‚´ì•„ìˆì„ ë•Œë§Œ publish)
    # -------------------------------------------------
    def stop(self):
        """ë¡œë´‡ ì •ì§€: linear, angular ëª¨ë‘ 0ìœ¼ë¡œ publish
        rclpyê°€ ì´ë¯¸ shutdown ëœ ìƒíƒœì—¬ë„ ì˜ˆì™¸ëŠ” ì¡ì•„ì„œ ë¬´ì‹œ
        """
        try:
            if rclpy.ok():
                self.pub.publish(Twist())
        except Exception as e:
            print(f"[stop] publish ì‹¤íŒ¨ (ë¬´ì‹œí•¨): {e}")

    # -------------------------------------------------
    # PID ì§ì§„ : ê±°ë¦¬ ê¸°ë°˜ íš¡ë°©í–¥/heading ì˜¤ì°¨ + ì œì–´ì…ë ¥ ë¡œê¹…
    # -------------------------------------------------
    def move_forward_pid(self, distance=2.0, speed=1.5, target_heading=None):
        """ì§€ì •í•œ ê±°ë¦¬(distance)ë§Œí¼ target_heading ë°©í–¥ìœ¼ë¡œ PID ì§ì§„
        - ì§ì§„í•˜ë©´ì„œ heading ì˜¤ì°¨ â†’ PIDë¡œ angular.z ì œì–´
        - ë™ì‹œì— íš¡ë°©í–¥ ì˜¤ì°¨(lat_error)ë¥¼ ê³„ì‚°í•´ì„œ ë¡œê·¸ë¡œ ì €ì¥
        """
        self.wait_for_pose()
        self.straight_pid.reset()

        # ì¶œë°œ ìœ„ì¹˜
        start_x = self.pose.x
        start_y = self.pose.y

        # target_headingì´ ì—†ìœ¼ë©´ í˜„ì¬ headingì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©
        if target_heading is None:
            target_heading = self.pose.theta
        target_heading = angle_normalize(target_heading)

        msg = Twist()
        last_time = time.time()

        # --- íš¡ë°©í–¥ ì˜¤ì°¨ ê³„ì‚°ìš© ë‹¨ìœ„ ë²•ì„ ë²¡í„° n ---
        # ì§„í–‰ ë°©í–¥ ë‹¨ìœ„ë²¡í„° d = (cosÎ¸, sinÎ¸)
        # dì— ìˆ˜ì§ì¸ ë²•ì„  n = (-sinÎ¸, cosÎ¸)
        # ì§ì„ ì—ì„œ ì¢Œ/ìš°ë¡œ ì–¼ë§ˆë‚˜ ë²—ì–´ë‚¬ëŠ”ì§€ ì¸¡ì •í•  ë•Œ ì‚¬ìš©
        n_x = -math.sin(target_heading)
        n_y = math.cos(target_heading)

        # í˜„ì¬ ì§ì„  ë³€ ë²ˆí˜¸ (ë¡œê·¸ì—ì„œ êµ¬ë¶„ìš©)
        seg = self.segment_count

        while rclpy.ok():
            # ì¶œë°œì  ê¸°ì¤€ ì´ë™ëŸ‰
            dx = self.pose.x - start_x
            dy = self.pose.y - start_y
            moved = math.hypot(dx, dy)  # ì´ ë³€ì—ì„œ ì „ì§„í•œ ê±°ë¦¬ s

            # ëª©í‘œ ê±°ë¦¬ë§Œí¼ ì´ë™í•˜ë©´ ë£¨í”„ ì¢…ë£Œ
            if moved >= distance:
                break

            # ì„ ì†ë„ ì„¤ì •
            # â†’ ëì— ê°€ê¹Œì›Œì§ˆìˆ˜ë¡ ì¤„ì—¬ì„œ overshoot ì¤„ì´ê¸°
            msg.linear.x = speed * max(0.3, 1.0 - moved / distance)

            # í˜„ì¬ headingê³¼ ëª©í‘œ heading ì°¨ì´ (ì˜¤ì°¨)
            current_heading = self.pose.theta
            err = angle_normalize(target_heading - current_heading)

            # ğŸ‘‰ íš¡ë°©í–¥ ì˜¤ì°¨ ê³„ì‚°
            # ì¶œë°œì ì—ì„œ í˜„ì¬ ìœ„ì¹˜ê¹Œì§€ ë²¡í„° (dx, dy)ë¥¼
            # ë²•ì„ ë²¡í„° nì— íˆ¬ì˜í•œ ê°’ = ì§ì„ ì—ì„œ ì˜†ìœ¼ë¡œ ë²—ì–´ë‚œ ê±°ë¦¬
            lat_error = dx * n_x + dy * n_y   # [m]

            # ğŸ‘‰ ì§ì§„ êµ¬ê°„ ë¡œê·¸ (xì¶• = ê±°ë¦¬ s)
            self.straight_seg_idx.append(seg)  # ëª‡ ë²ˆì§¸ ë³€ì¸ì§€
            self.lat_err_s.append(moved)       # ê·¸ ë³€ì—ì„œ ì–¼ë§ˆë§Œí¼ ì™”ëŠ”ì§€
            self.lat_err.append(lat_error)     # ê·¸ë•Œ íš¡ë°©í–¥ ì˜¤ì°¨
            self.lat_head_err.append(err)      # ê·¸ë•Œ heading ì˜¤ì°¨

            # PID dt
            now = time.time()
            dt = now - last_time
            last_time = now

            # heading ì˜¤ì°¨ë¥¼ PID ì»¨íŠ¸ë¡¤ëŸ¬ì— ë„£ì–´ì„œ ê°ì†ë„ ê³„ì‚°
            w = self.straight_pid.update(err, dt)

            # ê°ì†ë„ ë„ˆë¬´ í¬ì§€ ì•Šê²Œ saturate
            max_w = 1.0
            if abs(w) > max_w:
                w = max_w if w > 0 else -max_w

            msg.angular.z = w

            # ğŸ‘‰ ì§ì§„ ì¤‘ ì¡°í–¥ ì œì–´ì…ë ¥ ë¡œê·¸
            self.straight_w.append(w)

            # ì‹¤ì œ publish + pose ê°±ì‹ 
            self.pub.publish(msg)
            rclpy.spin_once(self, timeout_sec=0.01)

        # ì§ì§„ ëë‚˜ë©´ ì •ì§€
        self.stop()

    # -------------------------------------------------
    # ì ˆëŒ€ê° PID íšŒì „ : íšŒì „ ì˜¤ì°¨ + ì œì–´ì…ë ¥ + ìµœì¢… ì˜¤ì°¨ ë¡œê¹…
    # -------------------------------------------------
    def rotate_to_angle_pid(self, target_angle):
        """í˜„ì¬ ìœ„ì¹˜ì—ì„œ ëª©í‘œ ì ˆëŒ€ê°(target_angle)ê¹Œì§€ PID íšŒì „
        - ì œìë¦¬ì—ì„œ ë„ëŠ” ë™ì‘
        - íšŒì „ ì¤‘ ì˜¤ì°¨/ì œì–´ì…ë ¥ì„ ìƒ˜í”Œë§í•´ì„œ ë¡œê·¸ë¡œ ë‚¨ê¸°ê³ 
          ë§ˆì§€ë§‰ì— ë‚¨ì€ ìµœì¢… ì˜¤ì°¨ë„ ë”°ë¡œ ê¸°ë¡
        """
        self.wait_for_pose()
        msg = Twist()
        self.turn_pid.reset()

        last_time = time.time()
        # íšŒì „ ì¢…ë£Œ ì˜¤ì°¨ í—ˆìš© ë²”ìœ„
        # 1e-3 rad â‰ˆ 0.057Â° ì •ë„ (ì•„ì£¼ ì‘ì€ ê°)
        tol = 1e-3
        final_err = 0.0

        while rclpy.ok():
            current = self.pose.theta
            err = angle_normalize(target_angle - current)
            final_err = err

            # ğŸ‘‰ íšŒì „ ì˜¤ì°¨ ìƒ˜í”Œ ë¡œê·¸
            self.turn_err.append(err)

            # ì˜¤ì°¨ê°€ ì¶©ë¶„íˆ ì‘ìœ¼ë©´ íšŒì „ ì¢…ë£Œ
            if abs(err) < tol:
                break

            now = time.time()
            dt = now - last_time
            last_time = now

            # PID ì»¨íŠ¸ë¡¤ë¡œ ê°ì†ë„ ê³„ì‚°
            w = self.turn_pid.update(err, dt)

            # ê°ì†ë„ saturate
            max_w = 1.0
            if abs(w) > max_w:
                w = max_w if w > 0 else -max_w

            msg.linear.x = 0.0    # íšŒì „ë§Œ í•˜ë¯€ë¡œ ì§ì§„ì€ 0
            msg.angular.z = w

            # ğŸ‘‰ íšŒì „ ì¤‘ ì œì–´ì…ë ¥ ë¡œê·¸
            self.turn_w.append(w)

            self.pub.publish(msg)
            rclpy.spin_once(self, timeout_sec=0.01)

        # ê° í„´ì´ ëë‚¬ì„ ë•Œ ìµœì¢… heading ì˜¤ì°¨ ê¸°ë¡ (ë¶€í˜¸ í¬í•¨)
        self.turn_final_err.append(final_err)

        self.stop()

    # -------------------------------------------------
    # ì‚¬ê°í˜• ê·¸ë¦¬ê¸° (laps=Noneì´ë©´ ë¬´í•œ ë°˜ë³µ)
    # -------------------------------------------------
    def draw_square(self, side=2.0, laps=None):
        """side ê¸¸ì´ì˜ ì •ì‚¬ê°í˜•ì„ laps ë°”í€´ ë§Œí¼ ê·¸ë¦¼
        - laps=Noneì´ë©´ ë¬´í•œ ë°˜ë³µ (ì‚¬ìš©ìê°€ Ctrl+C ì¹  ë•Œê¹Œì§€)
        - í˜„ì¬ pose ê¸°ì¤€ìœ¼ë¡œ 'ì´ìƒì ì¸ ì •ì‚¬ê°í˜•'ì„ ì •ì˜í•˜ê³ 
          ê·¸ ì½”ë„ˆ ì¢Œí‘œ ëŒ€ë¹„ ì‹¤ì œ ì½”ë„ˆ ì¢Œí‘œ ì˜¤ì°¨ë¥¼ ê¸°ë¡
        """
        self.wait_for_pose()

        # í˜„ì¬ headingì„ ê°€ì¥ ê°€ê¹Œìš´ 0/90/180/270Â° ì¶•ìœ¼ë¡œ ìŠ¤ëƒ…
        raw = self.pose.theta
        axis_idx = round(raw / (math.pi / 2.0))   # 0,1,2,3
        self.base_heading = axis_idx * (math.pi / 2.0)

        self.get_logger().info(
            f"ğŸ§­ Snap: raw={raw:.4f}, base={self.base_heading:.4f}"
        )

        # === âœ… ì´ìƒì ì¸ 4ê°œ ì½”ë„ˆ ì¢Œí‘œ ê³„ì‚° (ê¸°ì¤€: í˜„ì¬ ìœ„ì¹˜) ===
        x0, y0 = self.pose.x, self.pose.y
        h0 = self.base_heading

        # ì²« ë²ˆì§¸ ë³€ ë°©í–¥ ë‹¨ìœ„ë²¡í„° u
        ux, uy = math.cos(h0), math.sin(h0)
        # uì— ìˆ˜ì§ì¸ v (ë°˜ì‹œê³„ ë°©í–¥ 90ë„ íšŒì „)
        vx, vy = -math.sin(h0), math.cos(h0)

        # ì´ìƒì ì¸ ì½”ë„ˆ c0~c3 ê³„ì‚°
        c0 = (x0, y0)
        c1 = (x0 + side * ux,         y0 + side * uy)         # ì²« ë²ˆì§¸ ë³€ ë
        c2 = (c1[0] + side * vx,      c1[1] + side * vy)      # ë‘ ë²ˆì§¸ ë³€ ë
        c3 = (c2[0] - side * ux,      c2[1] - side * uy)      # ì„¸ ë²ˆì§¸ ë³€ ë
        self.corner_ref = [c0, c1, c2, c3]

        # ê¸°ì¤€ ê°ë„(base_heading)ìœ¼ë¡œ í•œ ë²ˆ ì •ë ¬
        self.rotate_to_angle_pid(self.base_heading)

        lap = 0
        while rclpy.ok() and (laps is None or lap < laps):
            # í•œ ë°”í€´ = 4ê°œì˜ ë³€
            for i in range(4):
                # ië²ˆì§¸ ë³€ì´ í–¥í•´ì•¼ í•  ì „ì—­ heading (0Â°,90Â°,180Â°,270Â° ë“±)
                side_heading = angle_normalize(
                    self.base_heading + i * math.pi / 2.0
                )

                # ëª‡ ë²ˆì§¸ ë³€ì¸ì§€ ì¹´ìš´íŠ¸ (ê±°ë¦¬-ì˜¤ì°¨ ê·¸ë˜í”„ì—ì„œ êµ¬ë¶„ìš©)
                self.segment_count += 1

                # --- ì§ì§„ ìˆ˜í–‰ ---
                self.move_forward_pid(
                    distance=side,
                    speed=1.5,
                    target_heading=side_heading,
                )

                # === âœ… ì½”ë„ˆì—ì„œ x, y, heading ì˜¤ì°¨ ê¸°ë¡ ===
                actual_x, actual_y = self.pose.x, self.pose.y
                ref_x, ref_y = self.corner_ref[i]      # ì´ìƒì ì¸ ië²ˆì§¸ ì½”ë„ˆ

                # ìœ„ì¹˜ ì˜¤ì°¨ (ì‹¤ì œ - ì´ìƒ)
                ex = actual_x - ref_x
                ey = actual_y - ref_y
                self.corner_err_x.append(ex)
                self.corner_err_y.append(ey)

                # í•´ë‹¹ ì½”ë„ˆì—ì„œì˜ ì´ìƒì ì¸ heading = side_heading
                current_heading = self.pose.theta
                h_err = angle_normalize(side_heading - current_heading)
                self.corner_err_heading.append(h_err)

                # ë‹¤ìŒ ë³€ ë°©í–¥ìœ¼ë¡œ íšŒì „
                next_heading = angle_normalize(
                    self.base_heading + (i + 1) * math.pi / 2.0
                )
                self.rotate_to_angle_pid(next_heading)

            lap += 1
            self.get_logger().info(f"âœ” Lap {lap} finished")

    # -------------------------------------------------
    # ğŸ“Š ë¡œê·¸ ê¸°ë°˜ ê·¸ë˜í”„ ê·¸ë¦¬ê¸°
    # -------------------------------------------------
    def plot_logs(self):
        """ì§€ê¸ˆê¹Œì§€ ìŒ“ì•„ë‘” ë¡œê·¸ë¥¼ ê°€ì§€ê³ 
        - ê¶¤ì  vs ì´ìƒ ì‚¬ê°í˜•
        - ê° side ëì—ì„œì˜ ìµœì¢… lateral error
        - ê° turn í›„ì˜ ìµœì¢… heading error
        - ê° cornerì—ì„œì˜ ex, ey, eÎ¸
        ê·¸ë˜í”„ë¡œ ì‹œê°í™”"""
        if len(self.path_t) == 0:
            print("No log data to plot.")
            return

        # =========================
        # FIGURE 1 : ê¶¤ì  (ì‹¤ì œ vs ì´ìƒ ì‚¬ê°í˜•)
        # =========================
        fig1, ax1 = plt.subplots(1, 1, figsize=(6, 6))
        ax1.plot(self.path_x, self.path_y, marker=".", label="Actual path")

        # ì´ìƒì ì¸ ì‚¬ê°í˜• ê²½ë¡œ (corner_ref ê¸°ì¤€)
        if len(self.corner_ref) == 4:
            xs_ideal = [c[0] for c in self.corner_ref] + [self.corner_ref[0][0]]
            ys_ideal = [c[1] for c in self.corner_ref] + [self.corner_ref[0][1]]
            ax1.plot(xs_ideal, ys_ideal, "--", label="Ideal square")

        ax1.set_title("Turtle Trajectory (Actual vs Ideal)")
        ax1.set_xlabel("X")
        ax1.set_ylabel("Y")
        ax1.set_aspect("equal", "box")
        ax1.grid(True)
        ax1.legend()
        fig1.tight_layout()

        # =========================
        # FIGURE 2 : ê° side ëì—ì„œì˜ ìµœì¢… lateral error
        # =========================
        fig2, ax2 = plt.subplots(1, 1, figsize=(8, 5))

        final_lat_errors = []
        if len(self.lat_err_s) > 0:
            # ê¸°ë¡ëœ ëª¨ë“  ë³€ ë²ˆí˜¸ ì§‘í•©
            segments = sorted(set(self.straight_seg_idx))
            for seg in segments:
                # í•´ë‹¹ ë³€(seg)ì— ì†í•˜ëŠ” ì¸ë±ìŠ¤ë“¤
                indices = [idx for idx, sg in enumerate(self.straight_seg_idx) if sg == seg]
                if not indices:
                    continue
                # ì´ ë³€ì—ì„œ ê±°ë¦¬ sê°€ ê°€ì¥ í° ì‹œì  = ë³€ì˜ ë ì§€ì 
                last_idx = max(indices, key=lambda k: self.lat_err_s[k])
                # ê·¸ ì§€ì ì˜ íš¡ë°©í–¥ ì˜¤ì°¨ë¥¼ ìµœì¢… ì˜¤ì°¨ë¡œ ì‚¬ìš©
                final_lat_errors.append(self.lat_err[last_idx])

            side_indices = list(range(1, len(final_lat_errors) + 1))
            ax2.bar(side_indices, final_lat_errors)
            ax2.axhline(0.0, color="k", linestyle="dashed", linewidth=0.8)
            ax2.set_title("Final Lateral Error at End of Each Side")
            ax2.set_xlabel("Side index")
            ax2.set_ylabel("Lateral error [m]")
            ax2.grid(True)

        fig2.tight_layout()

        # =========================
        # FIGURE 3 : ê° turn í›„ ìµœì¢… heading error
        # =========================
        fig3, ax3 = plt.subplots(1, 1, figsize=(8, 5))

        if len(self.turn_final_err) > 0:
            turn_idx = list(range(1, len(self.turn_final_err) + 1))
            ax3.bar(
                turn_idx,
                [abs(e) * 180.0 / math.pi for e in self.turn_final_err]  # degë¡œ ë³€í™˜
            )
            ax3.set_title("Final Heading Error after Each Turn")
            ax3.set_xlabel("Turn index")
            ax3.set_ylabel("Error [deg]")
            ax3.grid(True)

        fig3.tight_layout()

        # =========================
        # FIGURE 4 : ì½”ë„ˆë³„ x, y, heading ì˜¤ì°¨ (êµìˆ˜ë‹˜ ìš”êµ¬ ex, ey, eÎ¸)
        # =========================
        if len(self.corner_err_x) > 0:
            fig4, axes4 = plt.subplots(3, 1, figsize=(8, 10))
            fig4.subplots_adjust(hspace=0.5)

            N = len(self.corner_err_x)
            idx = list(range(1, N + 1))

            # (4-1) x ì˜¤ì°¨
            axes4[0].bar(idx, self.corner_err_x)
            axes4[0].set_title("Corner X Error")
            axes4[0].set_xlabel("Corner index")
            axes4[0].set_ylabel("e_x [m]")
            axes4[0].grid(True)

            # (4-2) y ì˜¤ì°¨
            axes4[1].bar(idx, self.corner_err_y)
            axes4[1].set_title("Corner Y Error")
            axes4[1].set_xlabel("Corner index")
            axes4[1].set_ylabel("e_y [m]")
            axes4[1].grid(True)

            # (4-3) heading ì˜¤ì°¨ (deg)
            axes4[2].bar(
                idx,
                [e * 180.0 / math.pi for e in self.corner_err_heading]
            )
            axes4[2].set_title("Corner Heading Error")
            axes4[2].set_xlabel("Corner index")
            axes4[2].set_ylabel("e_heading [deg]")
            axes4[2].grid(True)

            fig4.tight_layout()

        plt.show()


# -------------------------------------------------
# MAIN
# -------------------------------------------------
def main(args=None):
    """ë…¸ë“œ ì´ˆê¸°í™” â†’ ì‚¬ê°í˜• ê·¸ë¦¬ê¸° â†’ Ctrl+C ì‹œ ë¡œê·¸ í”Œë¡œíŒ…"""
    rclpy.init(args=args)
    node = TurtleSquareUltra()

    try:
        # laps=None ì´ë©´ ë¬´í•œ ì‚¬ê°í˜• (Ctrl+C ì¹  ë•Œê¹Œì§€ ê³„ì†)
        node.draw_square(side=2.0, laps=None)
    except KeyboardInterrupt:
        print("\n\nğŸ›‘ KeyboardInterrupt: plotting logs...")
    finally:
        # ì •ì§€ ì‹œë„ (ì´ë¯¸ shutdown ëœ ìƒíƒœì—¬ë„ stop ë‚´ë¶€ì—ì„œ ì˜ˆì™¸ ì²˜ë¦¬)
        node.stop()

        # ROS ì¢…ë£Œ: ì´ë¯¸ shutdownëœ ìƒíƒœë©´ ì˜ˆì™¸ ë¬´ì‹œ
        try:
            if rclpy.ok():
                rclpy.shutdown()
        except Exception as e:
            print(f"[shutdown] ì´ë¯¸ ì¢…ë£Œëœ ê²ƒ ê°™ì•„ì„œ íŒ¨ìŠ¤: {e}")

        # ë§ˆì§€ë§‰ìœ¼ë¡œ ê·¸ë˜í”„ ì¶œë ¥
        node.plot_logs()


if __name__ == "__main__":
    main()
